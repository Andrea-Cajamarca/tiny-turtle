<!DOCTYPE html>
<meta charset="utf-8">
<title>TinyTurtle Lab</title>
<style>
canvas {
  border: 1px dotted gray;
}

#code {
  display: block;
}

#error {
  background: pink;
  min-height: 2em;
  /* Errors can take some time to fade in b/c we don't want to
   * needlessly distract the user. */
  transition: opacity 1s 0.25s;
}

#error:not(.shown) {
  opacity: 0;
  /* Errors should disappear instantaneously to let the user know
   * everything is okay now. */
  transition: opacity 0.25s 0.01s;
}
</style>
<a href="https://github.com/toolness/tiny-turtle"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
<h1>TinyTurtle Lab</h1>
<canvas id="canvas" width="200" height="200"></canvas>
<div id="error"></div>
<textarea id="code" rows="25" cols="50"></textarea>
<div id="timeout-msg" style="display: none">
  Your code has taken too long to execute. Perhaps it contains
  an infinite loop?
</div>
<script id="sample" type="javascript/sample-code">
function box(length) {
  for (var i = 0; i < 4; i++) {
    forward(length);
    right(90);
  }
}

penStyle = 'purple';
box(90);
left(10);
box(80);
left(10);
box(70);
</script>
<script src="tiny-turtle.js"></script>
<script>
var $ = document.querySelector.bind(document);
var worker;
var source;
var renderDelayTimeout;
var workerTimeout;
var code = $("#code");
var canvas = $("#canvas");
var error = $("#error");

var RENDER_DELAY_MS = 100;
var WORKER_TIMEOUT_MS = 2000;
var WORKER_TIMEOUT_MSG = $("#timeout-msg").textContent;
var SAMPLE_JS = $("#sample").textContent.trim();

function queueRendering() {
  clearTimeout(renderDelayTimeout);
  renderDelayTimeout = setTimeout(render, RENDER_DELAY_MS);
}

function killWorker() {
  if (!worker) return;
  clearTimeout(workerTimeout);
  worker.terminate();
  worker = null;
}

function finishWorker(lines, err) {
  killWorker();
  if (err) {
    error.classList.add("shown");
    error.textContent = err.message;
    // If nothing was displayed, don't draw an empty canvas, b/c we don't
    // want to unnecessarily distract the user if they're in the middle
    // of typing.
    if (!lines.length) return;
    // Otherwise, show what was drawn before the error as a debugging
    // aid.
  } else {
    // Note that we would just use classList.toggle() with !!err as
    // the second arg, but it appears to be broken in IE10.
    error.classList.remove("shown");
  }
  canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
  lines.forEach(function(line) {
    TinyTurtle.drawLine.apply(TinyTurtle, [canvas].concat(line));
  });
}

function render() {
  var lines = [];

  if (code.value == source) return;
  source = code.value;
  killWorker();
  worker = new Worker("index.worker.js");
  worker.onmessage = function(e) {
    var data = e.data;
    if (data.msg == 'line')
      lines.push(data.args)
    else if (data.msg == 'done')
      finishWorker(lines, null);
  };
  worker.onerror = finishWorker.bind(null, lines);
  worker.postMessage({
    source: code.value,
    height: canvas.height,
    width: canvas.width
  });
  workerTimeout = setTimeout(function() {
    finishWorker(lines, new Error(WORKER_TIMEOUT_MSG));
  }, WORKER_TIMEOUT_MS);
}

if (!code.value) code.value = SAMPLE_JS;
render();
code.onkeyup = code.onchange = queueRendering;
</script>
